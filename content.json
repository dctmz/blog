{"meta":{"title":"DCTMZ's blog","subtitle":"一个自由的小小小团队","description":"每天学习一点点，终有一天小鸟会长大","author":"dctmz","url":"https://dctmz.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-11-29T08:31:04.428Z","updated":"2021-11-29T08:31:04.428Z","comments":false,"path":"/404.html","permalink":"https://dctmz.github.io/blog/404.html","excerpt":"","text":""},{"title":"关于我们","date":"2021-12-28T06:47:43.713Z","updated":"2021-12-28T06:47:43.706Z","comments":false,"path":"about/index.html","permalink":"https://dctmz.github.io/blog/about/index.html","excerpt":"","text":"小小的公司 小小的Web Front 有一个小小的地方 记录一点小小的事情"},{"title":"分类","date":"2021-11-29T08:31:04.612Z","updated":"2021-11-29T08:31:04.612Z","comments":false,"path":"categories/index.html","permalink":"https://dctmz.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-11-29T08:31:04.551Z","updated":"2021-11-29T08:31:04.550Z","comments":false,"path":"books/index.html","permalink":"https://dctmz.github.io/blog/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-29T08:31:04.734Z","updated":"2021-11-29T08:31:04.734Z","comments":false,"path":"repository/index.html","permalink":"https://dctmz.github.io/blog/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-29T08:31:04.795Z","updated":"2021-11-29T08:31:04.795Z","comments":false,"path":"tags/index.html","permalink":"https://dctmz.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-29T08:31:04.673Z","updated":"2021-11-29T08:31:04.673Z","comments":true,"path":"links/index.html","permalink":"https://dctmz.github.io/blog/links/index.html","excerpt":"","text":""}],"posts":[{"title":"fix moment Deprecation warning","slug":"moment-Deprecation-warning-value-provided-is-not-in-a-recognized-RFC2822-or-ISO-format","date":"2021-12-30T02:13:26.000Z","updated":"2021-12-30T02:39:07.414Z","comments":true,"path":"2021/12/30/moment-Deprecation-warning-value-provided-is-not-in-a-recognized-RFC2822-or-ISO-format/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/30/moment-Deprecation-warning-value-provided-is-not-in-a-recognized-RFC2822-or-ISO-format/","excerpt":"在开发后台也页面的时候，发现控制台报了如下警告 ⚠️ 1234react_devtools_backend.js:4045 Deprecation warning: value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.Arguments:[0] _isAMomentObject: true, _isUTC: false, _useUTC: false, _l: undefined, _i: 2021/12/21, _f: undefined, _strict: undefined, _locale: [object Object]Error","text":"在开发后台也页面的时候，发现控制台报了如下警告 ⚠️ 1234react_devtools_backend.js:4045 Deprecation warning: value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.Arguments:[0] _isAMomentObject: true, _isUTC: false, _useUTC: false, _l: undefined, _i: 2021/12/21, _f: undefined, _strict: undefined, _locale: [object Object]Error 原因翻译了一下，大概意思是 弃用警告：提供的值不是可识别的 RFC2822 或 ISO 格式。Moment 构造退回到 js date()，它在所有浏览器和版本中都不可靠。不推荐使用非 RFC2822/ISO 日期格式。有关更多信息，请访问http://momentjs.com/guides/#/warnings/js-date/。 后来找了一下后端返回的时间格式为 “YYYY/MM/DD” 解决方案 重新格式化12const str = &quot;2021/11/11&quot;;moment(str.replace(&quot;/&quot;, &quot;-&quot;)).format(&quot;YYYY-MM-DD&quot;); 关闭提示1moment.suppressDeprecationWarnings = true; 增加时间构造12const str = &quot;2021/11/11&quot;;moment(new Date(str)).format(&quot;YYYY-MM-DD&quot;); 🔥 后端改为正确格式(推荐)追其根本是后端返回格式和前端要的格式不匹配，所以改为正确格式才能一劳永逸 参考资料 https://momentjs.com/guides/#/warnings/js-date/ https://stackoverflow.com/questions/39969570/deprecation-warning-in-moment-js-not-in-a-recognized-iso-format https://en.wikipedia.org/?title=RFC_2822&amp;redirect=no","categories":[{"name":"开发","slug":"开发","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"moment","slug":"moment","permalink":"https://dctmz.github.io/blog/tags/moment/"},{"name":"js","slug":"js","permalink":"https://dctmz.github.io/blog/tags/js/"},{"name":"warning","slug":"warning","permalink":"https://dctmz.github.io/blog/tags/warning/"}]},{"title":"h5跳转微信小程序","slug":"h5跳转微信小程序","date":"2021-12-29T03:13:17.000Z","updated":"2021-12-29T09:41:23.158Z","comments":true,"path":"2021/12/29/h5跳转微信小程序/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/29/h5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"本文介绍 h5 如何跳转微信小程序","text":"本文介绍 h5 如何跳转微信小程序 概述 为了更好的将用户引流到小程序。所以就需要 H5 跳到小程序的功能。用到了微信开放标签 wx-open-launch-weapp 前期准备 登录微信小程序公众平台-设置-账号信息 获取小程序 AppID 及原始 ID H5 跳转小程序的路径及参数 获取 URL Scheme 开发html &lt;wx-open-launch-weapp username=&quot;gh_XXXX&quot; path=&quot;pages/xx/xx&quot;&gt; &lt;script type=&quot;text/wxtag-template&quot;&gt; &lt;button&gt;打开小程序&lt;/button&gt; &lt;/script&gt; &lt;/wx-open-launch-weapp&gt; 通过 wx-open-launch-weapp 标签可以 h5 跳转到小程序，在真机上才可以看到按钮，为了解析得到微信的标签 script 需要加上这个 type=”text/wxtag-template”，按钮的样式必须是行内样式才能有效果；在 vue 里，script 可以改成 template，能直接平铺到页面上，点击根据判断浏览器来跳转；username 是小程序的原始 ID；path 是跳转小程序的路径，可以带参数（按照正常的路由携带参数即可） js // 是否为移动端 export const isMobile = /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|IEMobile)/i.test( window.navigator.userAgent.toLowerCase() ); // 支付宝浏览器 export const isZFBWork =/Alipay/i.test(window.navigator.userAgent.toLowerCase()); // 判断是移动端且不是支付宝浏览器后跳转微信 if(isMobile &amp;&amp; !isZFBWork) &#123; // 提前获取XXXXX window.location.href = &#39;weixin://dl/business/?t=XXXXX&#39; &#125; 首先要判断是否是移动端，后判断是否是支付宝(支付宝浏览器不支持打开微信小程序，支付宝可以提示用户打开浏览器再去跳转), weixin://dl/business/?t=XXXXX（也可以转为短链）这个链接可以从浏览器唤起本地微信 app，并打开相关小程序。 如何获取 URL Scheme (weixin://dl/business/?t=XXXXX 中的 XXXXX) 通过服务端接口或在小程序管理后台「工具」-「生成 URL Scheme」入口可以获取打开小程序任意页面的 URL Scheme。适用于从短信、邮件、微信外网页等场景打开小程序。 通过 URL Scheme 打开小程序的场景值为 1065。生成的 URL Scheme 如下所示： weixin://dl/business/?t= TICKETiOS 系统支持识别 URL Scheme，可在短信等应用场景中直接通过 Scheme 跳转小程序。Android 系统不支持直接识别 URL Scheme，用户无法通过 Scheme 正常打开小程序，开发者需要使用 H5 页面中转，再跳转到 Scheme 实现打开小程序，跳转代码示例如下： location.href = ‘weixin://dl/business/?t= TICKET‘该跳转方法可以在用户打开 H5 时立即调用，也可以在用户触发事件后调用。 调用上限 Scheme 将根据是否为到期有效与失效时间参数，分为短期有效 Scheme 与长期有效 Scheme： 单个小程序每日生成 Scheme 上限为 50 万个（包含短期有效 Scheme 与长期有效 Scheme）有效时间超过 180 天的 Scheme 或永久有效的 Scheme 为长期有效 Scheme，单个小程序总共可生成长期有效 Scheme 上限为 10 万个，请谨慎调用有效时间不超过 180 天的 Scheme 为短期有效 Scheme，单个小程序生成短期有效 Scheme 不设上限 注意事项 微信内的网页如需打开小程序请使用微信开放标签-小程序跳转按钮，无公众号也可以直接使用小程序身份开发网页并免鉴权跳转小程序，见云开发静态网站跳转小程序。符合开放范围的小程序可以下发支持打开小程序的短信该功能基本覆盖当前用户正在使用的微信版本，开发者无需进行低版本兼容只能生成已发布的小程序的 URL Scheme通过 URL Scheme 跳转到微信时，可能会触发系统弹框询问，若用户选择不跳转，则无法打开小程序。请开发者妥善处理用户选择不跳转的场景部分浏览器会限制打开网页直接跳转，可参考示例网页设置跳转按钮 开放范围 针对非个人主体小程序开放。 跳转原理分析： 从手机浏览器等非微信环境，跳转到微信，都是利用 weixin://dl/business/?ticket=XXXX 这种形式的微信 scheme,提供给这些商家的接口，把我们的链接转换成对应的 ticket 链接。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://dctmz.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"h5","slug":"h5","permalink":"https://dctmz.github.io/blog/tags/h5/"},{"name":"小程序","slug":"小程序","permalink":"https://dctmz.github.io/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"前端的部署方式","slug":"前端的部署方式","date":"2021-12-28T07:42:19.000Z","updated":"2021-12-28T08:29:00.621Z","comments":true,"path":"2021/12/28/前端的部署方式/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/28/%E5%89%8D%E7%AB%AF%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/","excerpt":"随着前端的发展，从最早的静态页面，到后来的动态页面，再到后来的前后端分离，前端部署方式也随着变化。这篇文章就简单记录下，前端的一些部署方式。","text":"随着前端的发展，从最早的静态页面，到后来的动态页面，再到后来的前后端分离，前端部署方式也随着变化。这篇文章就简单记录下，前端的一些部署方式。 原理其实本质上来说前端页面无非就是一些静态资源，用户通过URI的方式访问这些静态资源。 在电脑术语中，统一资源标识符（Uniform Resource Identifier，URI)是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。 – 百度百科 那么其实只要能够有一个静态资源服务即可部署一个前端网站。 访问方式本来通过URI用户可以直接访问资源，但是前端目前有两种路由方式 hash history history的方式好处理，跟之前的没有太大区分，hash的方式就比较特别了。 history体现在URL上的话，就是 1https://www.baidu.com/s?wd=name 域名抛去不看，只看资源路径的话/s，只要服务器能够返回这个文件即可。此时需要服务器有多份静态资源，当然前端独立部署之后，也可以只有一份静态资源，具体方式往下看。 hash体现在URL上的话就是 1https://www.baidu.com/#/s 路径为/，那么问题来了，怎么访问到不同的资源呢，这时候服务端需要不管资源路径为什么，都必须返回一个页面文件。不同的资源通过hash来定位，即#/s来定位，页面通过js判断不同的hash来确定执行什么样的方法，来给用户展示不同的页面。 当然这时候需要静态服务器做一些特殊的处理，在访问任何路径的时候都返回同一个html页面。 常见的部署方式从上面的原理来看，部署方式就很简单了，我们常见的可能有几种 nginxnginx作为一个反向代理服务器，可谓是本领强大，轻松启动一个静态服务更是不在话下，只要我们把静态资源放在服务器上，然后用nginx做代理即可 ossoss虽然是一个对象管理，但是它提供了一个静态网站服务，只要开启后就可以当做一个静态网站了。 pagespages服务有很多，比如GitHub，gitee等都有提供。 后端提供后端一般都会提供一个静态服务","categories":[{"name":"开发","slug":"开发","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dctmz.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"deploy","slug":"deploy","permalink":"https://dctmz.github.io/blog/tags/deploy/"},{"name":"front","slug":"front","permalink":"https://dctmz.github.io/blog/tags/front/"},{"name":"webpack","slug":"webpack","permalink":"https://dctmz.github.io/blog/tags/webpack/"}]},{"title":"闲聊团队","slug":"闲聊团队","date":"2021-12-28T07:13:53.000Z","updated":"2021-12-28T07:39:13.594Z","comments":true,"path":"2021/12/28/闲聊团队/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/28/%E9%97%B2%E8%81%8A%E5%9B%A2%E9%98%9F/","excerpt":"目标一致，齐心协力。则为团队 日常工作中，经常会碰到各种各样的问题，有技术上，也有不少技术上的。通常我们碰到问题的第一想法是，我该怎么解决呢？然后一个人就不停的尝试。后来一个小故事改变了我，其实询问别人也是一种解决方案，而且可能还更有效。","text":"目标一致，齐心协力。则为团队 日常工作中，经常会碰到各种各样的问题，有技术上，也有不少技术上的。通常我们碰到问题的第一想法是，我该怎么解决呢？然后一个人就不停的尝试。后来一个小故事改变了我，其实询问别人也是一种解决方案，而且可能还更有效。 我们每个人作为一个独立的个体，能力总是会有边界的。这时候团队就能帮助我们弥补这样的边界。可现实中很多人都忘记了，你旁边其实坐了一个能够帮助你的人。 之所以会想到这个，是因为我在工作和生活中经常会碰到大家都是独立的在干活，很少有团队合作的意识。 作为一个程序员，能深切感受到程序员有一个想法，就是代码还是自己写的好，最好别让我跟别人一起写一个项目。 作为一个父亲，总想着有孩子她妈呢，再扣会儿手机，家务等会再做。 … 在聊以下话题的时候，我想必须先有个共识，这是我在看《丰田模式》的时候的一些感悟，书中说一个企业应该是为社会创造价值，为股东创造价值，为员工创造价值，为合作伙伴创造价值，并且以长期利益为导向，而不是短期利益。如果说没有此前提，那么后面的就无从谈起了。 团队需要建设团队不能凭空产生，建设团队需要我们付出行动，如何挑选团队成员，需要我们花点心思，并且应该足够重视。不断优化挑选模型。 在挑选过程中我们必须摒除偏见，这一点很难做到，我们常常用我们过往的经验来判断一个人。 给人贴标签虽然是一种快速认识人的方式，但是也给我们带来了很多负面的东西，比如不能客观和全面的看待一个人。 团队需要培养我们应该跟团队共同成长，帮助团队成员达到新的高度，是我们应该和必须做的事情。 组织培训 给团队成员锻炼的机会 … 团队的短板决定团队的总体能力有个斜木桶理论，但我个人认为即便是斜的，团队里的短板还是决定了团队的整体能力。想要摆脱，要么舍弃短板，要么补齐。 但我并不赞成舍弃，如果说员工可以舍弃，那么孩子呢？家人呢？我们需要锻炼的是团队的包容力。 感性识人，理性做事在工作中，我经常碰到很多人用感性去判断别人，而忘记了本来的目的。 理性的跟人合作需要修炼，但不是不能做到。 感性识人在跟人交流的时候我们需要感性，需要同理心，你面对的是一个活生生的人，而不是一个理性机器，在考虑问题的时候，我们需要观察，并给出客观合理的推论。 人们有时候会开心，会沮丧，会抗拒，但这只是人的情绪，能控制情绪的人固然很好，但不能奢求每个人都能这样，所以体会别人的情绪，了解别人的感受很重要 理性做事在了解别人之后，做出理性的判断，而不是根据表面去否定一个人，这样合作将无法继续。只有回归理性，才能不往初心，朝着目标而去。 总结随着社会的发展，我们越来越不可能仅靠单打独斗就能做好一些事情，所以有一个好团队十分重要，祝愿大家能找到自己的团队，并随着团队一起成长。","categories":[{"name":"思考","slug":"思考","permalink":"https://dctmz.github.io/blog/categories/%E6%80%9D%E8%80%83/"}],"tags":[{"name":"team","slug":"team","permalink":"https://dctmz.github.io/blog/tags/team/"},{"name":"团队","slug":"团队","permalink":"https://dctmz.github.io/blog/tags/%E5%9B%A2%E9%98%9F/"}]},{"title":"前端项目代码检查工具","slug":"前端项目代码检查工具","date":"2021-12-21T07:03:00.000Z","updated":"2021-12-28T06:40:44.431Z","comments":true,"path":"2021/12/21/前端项目代码检查工具/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/21/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/","excerpt":"本文介绍在项目开发所用到的代码检查工具","text":"本文介绍在项目开发所用到的代码检查工具 原因（为什么我们需要代码检查工具）规范团队代码风格。 每个团队或个人都会有自己的编码习惯和代码风格，为了便于后期维护和阅读，我们需要统一代码格式规范： 空格， 统一缩进 命名规范 … 避免开发中出现低级 bug 一些常见代码问题（例如手误引起的语法问题），如果在编译或运行前不能及时发现，代码中的语法问题会直接导致编译或运行时错误，影响开发效率和代码质量。 提高代码质量和开发效率 开发常用的代码检查工具 SonarLint Code Spell Checker ESLint | Prettier Git Hook SonarLint Sonar 是一个代码质量管理的开源工具，它通过插件的形式能够识别常见的多种编程语言（例如 Java, C#, PHP, Pythod 等）代码质量问题。Sonar 可以帮你分析出以下代码质量问题： 1.不遵循代码标准； 2.潜在的缺陷，比如空指针、bug； 3.代码重复； 4.注释率不足或过高； 5.糟糕的复杂度，比如 if/循环嵌套太多、类/方法太大； 6.缺乏单元测试； 在公司中，一般是把 SonarQube 部署在服务器端，当开发人员提交代码时，Jenkins 触发 SonarQube 进行代码检查，开发人员根据代码检查结果进行问题修复。但是这样，开发人员往往只会关注被阻断的代码问题，对于 Sonar 提示的设计、性能方面的问题往往视而不见。 SonarLint 插件，可以在 IDE(Intellij Idea、Eclipse)中嵌入，这样开发人员不仅能使用 SonarLint 中内置的代码检查规则进行代码检查，也可以连接到远端服务器拉取远端规则。有了它，我们就可以在编写代码的过程中根据 SonarLint 的提示编写高质量代码了。 安装以 vscode 为例，在侧边栏找到扩展商店搜索 [SonarLint] 点击 install。安装完成之后重新加载编辑器。 代码检查SonarLint 插件安装后，就可以使用它对 Idea 中的项目进行代码检查了。SonarLint 能够对单个文件、整个项目、从 VCS（版本控制系统，比如 git、svn 等）拉取的被修改文件这 3 类进行检查。 Code Spell Checker Code Spell Checker 是 VSCode 一款检查语法规则的插件，能够帮助我们检查单词拼写是否出现错误，检查的规则遵循 camelCase （驼峰拼写法）。 安装打开 vscode，在侧边栏找到扩展商店搜索 [code spell checker] 点击 install。安装完成之后重新加载编辑器。 代码检查在编写代码的过程中，变量未遵循驼峰拼写法的规则时，则会在其下方出现波浪线警告。 ESLint | Prettier ESlint 高度可定制，不依赖与特定的编码约定，用户可以自由地启用或禁用各个编码约定。 ESlint 会对我们的代码格式进行一些检测（比如分号、单双引号等），但是并不能完全统一代码风格，我们还需要一个工具 Prettier。 prettier 是校验代码格式化的工具。它并不关心你的语法是否正确，只关心你的代码格式，比如是否使用单引号，语句结尾是否使用分号等等，不仅可以用来检测 JavaScript 代码格式，还可以检测 vue 文件，react 文件。 安装打开 vscode，在侧边栏找到扩展商店搜索 [eslint] 和 [prettier code formatter] 点击 install。安装完成之后重新加载编辑器。 12npm install eslint -Dnpm install eslint-config-prettier -D 文件配置eslint 安装之后，可以执行 eslint --init 来生成一个默认的配置文件 .eslintrcESlint 支持 6 种格式的配置文件，其使用的优先级和说明如下： .eslintrc.js：模块定义，export 的对象即为配置对象 .eslintrc.yaml：yaml 语法 .eslintrc.yml：yaml 语法 .eslintrc.json：JSON 语法 .eslintrc：兼容 yaml 和 JSON 语法 package.json： 在 package.json 的 eslintConfig 字段中定义 .eslintrc.json 文件示例：（详细的配置项点击这里） 123456789101112&#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125; &#125;, &quot;rules&quot;: &#123; &quot;semi&quot;: &quot;error&quot; &#125;&#125; 命令行12345678910111213141516171819202122// 指定配置文件eslint --config ~/my-eslint.json file.js// 关闭配置文件eslint --no-eslintrc file.js// 指定运行环境eslint --env browser,node file.js// 指定需要进行代码检查的文件后缀eslint . --ext .js --ext .JSX// 定义全局变量eslint --global require,exports:true file.js// 将stdin作为代码源，指定解析器echo &#x27;3 ** 4&#x27; | eslint --stdin --parser-options=ecmaVersion:7// 使用缓存，指定缓存文件位置eslint &quot;src/**/*.js&quot; --cache --cache-location &quot;/Users/user/.eslintcache/&quot;// 指定插件eslint --plugin eslint-plugin-mocha file.js// 关闭warning输出eslint --quiet file.js// 指定报告输出文件eslint --output-file ./test/test.html//修复部分问题eslint --fix Prettier 配置（详细的配置项点击这里） 可以在 esLint 中添加 plugin 配置 prettier。比如： 123456&#123; plugins: [&quot;prettier&quot;], rules: &#123; prettier/prettier: &quot;error&quot; &#125;&#125; 也可以在项目中新建一个.prettierrc.json文件： 12345678910111213141516&#123; // 尾逗号 &quot;trailingComma&quot;: &quot;es5&quot;, // 缩进长度 &quot;tabWidth&quot;: 4, // 代码末尾分号 &quot;semi&quot;: false, // 单引号 &quot;singleQuote&quot;: true, // 单行代码最大长度 &quot;printWidth&quot;: 100, // 对象字面量的括号 &quot;bracketSpacing&quot;: true, // 箭头函数参数加括号 &quot;arrowParens&quot;: &quot;always&quot;&#125; 以上是开发中用到的代码检查工具。下面介绍 git hook 强制执行编码风格检测与修正。 Git Hook 借助 Git Hook，可以在提交代码时执行风格检测与修正，当存在无法通过的内容时，提交会被 block，从而实现编码规范的强制性执行。 husky 它会安装一系列 git hook 到项目的 .git/hook 目录中，这些钩子可以检测 package.json 中的 scripts 脚本命令配置，并在代码提交时执行它（我们这里利用 pre-commit 钩子） lint-staged 可以取得所有被提交的文件并依次执行配置好的任务命令 styleLint/TSLint/ESlint 各种 lint 校验工具，可以配置到 lint-staged 的任务中 prettier 配置到 lint-staged 的任务中，可以实现修正可自动格式化的编码风格 通过以上配置，当代码提交时，会在 pre-commit 阶段执行 .git/hook/precommit 钩子，该钩子会查找并执行 scrpits 中的 precommit 命令，于是 lint-staged 定义的任务会被逐个执行。这套方案也是当前比较流行的做法，在很多开源项目中都有所应用。 结语结束语：执行 Code Review 也很重要。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://dctmz.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"lint","slug":"lint","permalink":"https://dctmz.github.io/blog/tags/lint/"},{"name":"sonarLint","slug":"sonarLint","permalink":"https://dctmz.github.io/blog/tags/sonarLint/"},{"name":"spellChecker","slug":"spellChecker","permalink":"https://dctmz.github.io/blog/tags/spellChecker/"}]},{"title":"一个npm包的发布记录","slug":"一个npm包的发布记录","date":"2021-12-02T09:33:58.000Z","updated":"2021-12-02T10:47:36.316Z","comments":true,"path":"2021/12/02/一个npm包的发布记录/","link":"","permalink":"https://dctmz.github.io/blog/2021/12/02/%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%B0%E5%BD%95/","excerpt":"项目越来越多，有很多公用功能，没必要再写一遍了，这里记录下怎么将一个 npm 包发到 npmjs.com","text":"项目越来越多，有很多公用功能，没必要再写一遍了，这里记录下怎么将一个 npm 包发到 npmjs.com 前期准备脚手架搭建开始开发发布总结","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://dctmz.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://dctmz.github.io/blog/tags/npm/"},{"name":"git","slug":"git","permalink":"https://dctmz.github.io/blog/tags/git/"}]},{"title":"postman动态设置变量","slug":"postman设置变量","date":"2021-11-30T08:35:30.000Z","updated":"2021-11-30T08:47:16.712Z","comments":true,"path":"2021/11/30/postman设置变量/","link":"","permalink":"https://dctmz.github.io/blog/2021/11/30/postman%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F/","excerpt":"本文介绍下我在开发中遇到了 postman 调试接口时，遇到了没个接口都需要带一个自定义的请求头，而且是动态获取的，这里记录下我是怎么做的","text":"本文介绍下我在开发中遇到了 postman 调试接口时，遇到了没个接口都需要带一个自定义的请求头，而且是动态获取的，这里记录下我是怎么做的 原因在开发中我碰到这种情况，每个请求接口都需要带上一个自定义的请求头，格式如下 1&quot;Access-Token&quot;:&quot;token12345&quot; 而且token是从登陆接口获取的，每半小时失效 这时候我设置了一个环境变量&#123;&#123;TOKEN&#125;&#125; 那么问题来了，我怎么动态设置这个 token 呢 原理postman是提供请求前置（pre-request Script）和请求后置（Tests）的，而且在里面可以设置变量，发送请求等动作 方案在Tests中设置，如下 123456pm.test(&quot;设置token&quot;, function () &#123; // 获取登陆后的相应json var jsonData = pm.response.json(); // 设置token pm.environment.set(&#x27;TOKEN&#x27;,jsonData.data.token)&#125;); 此时当你每次发送请求的时候就会动态设置环境变量了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"postman","slug":"postman","permalink":"https://dctmz.github.io/blog/tags/postman/"},{"name":"env","slug":"env","permalink":"https://dctmz.github.io/blog/tags/env/"}]},{"title":"hexo 博客搭建","slug":"hexo-install-and-deploy","date":"2021-11-29T02:53:10.000Z","updated":"2021-11-30T08:48:05.390Z","comments":true,"path":"2021/11/29/hexo-install-and-deploy/","link":"","permalink":"https://dctmz.github.io/blog/2021/11/29/hexo-install-and-deploy/","excerpt":"本文介绍博客搭建的过程","text":"本文介绍博客搭建的过程 初始化仓库 申请 GitHub 账号 创建仓库 安装和配置主题安装博客https://hexo.io/zh-cn/ 使用以下命令安装博客 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 安装主题我这里使用的是 pure 在博客目录下面运行 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 配置主题 在项目目录下面新建_config.pure.yml 复制themes/pure/_config.yml文件的内容到_config.pure.yml 配置你的内容 部署到 GitHub安装插件在项目根目录下运行以下命令 1npm install hexo-deployer-git --save 配置插件在项目根目录下的_config.yml找到deploy配置项 12345deploy: type: git repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 配置好后如下 1234deploy: type: git repo: git@github.com:dctmz/blog.git #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: gh-pages 运行发布命令1hexo clean &amp;&amp; hexo deploy GitHub 设置一般情况下，GitHub 已经自动设置好了，如果没有设置好，找到page设置 我的设置如下 预览接下来就可以访问你的博客了，如我的网址为 https://dctmz.github.io/blog/ 改为你的地址即可 1https://[username].github.io/[repo]/","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dctmz.github.io/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://dctmz.github.io/blog/tags/blog/"},{"name":"github","slug":"github","permalink":"https://dctmz.github.io/blog/tags/github/"},{"name":"pure","slug":"pure","permalink":"https://dctmz.github.io/blog/tags/pure/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端开发","slug":"前端开发","permalink":"https://dctmz.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"思考","slug":"思考","permalink":"https://dctmz.github.io/blog/categories/%E6%80%9D%E8%80%83/"},{"name":"开发工具","slug":"开发工具","permalink":"https://dctmz.github.io/blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"moment","slug":"moment","permalink":"https://dctmz.github.io/blog/tags/moment/"},{"name":"js","slug":"js","permalink":"https://dctmz.github.io/blog/tags/js/"},{"name":"warning","slug":"warning","permalink":"https://dctmz.github.io/blog/tags/warning/"},{"name":"h5","slug":"h5","permalink":"https://dctmz.github.io/blog/tags/h5/"},{"name":"小程序","slug":"小程序","permalink":"https://dctmz.github.io/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"前端","slug":"前端","permalink":"https://dctmz.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"deploy","slug":"deploy","permalink":"https://dctmz.github.io/blog/tags/deploy/"},{"name":"front","slug":"front","permalink":"https://dctmz.github.io/blog/tags/front/"},{"name":"webpack","slug":"webpack","permalink":"https://dctmz.github.io/blog/tags/webpack/"},{"name":"team","slug":"team","permalink":"https://dctmz.github.io/blog/tags/team/"},{"name":"团队","slug":"团队","permalink":"https://dctmz.github.io/blog/tags/%E5%9B%A2%E9%98%9F/"},{"name":"lint","slug":"lint","permalink":"https://dctmz.github.io/blog/tags/lint/"},{"name":"sonarLint","slug":"sonarLint","permalink":"https://dctmz.github.io/blog/tags/sonarLint/"},{"name":"spellChecker","slug":"spellChecker","permalink":"https://dctmz.github.io/blog/tags/spellChecker/"},{"name":"npm","slug":"npm","permalink":"https://dctmz.github.io/blog/tags/npm/"},{"name":"git","slug":"git","permalink":"https://dctmz.github.io/blog/tags/git/"},{"name":"postman","slug":"postman","permalink":"https://dctmz.github.io/blog/tags/postman/"},{"name":"env","slug":"env","permalink":"https://dctmz.github.io/blog/tags/env/"},{"name":"hexo","slug":"hexo","permalink":"https://dctmz.github.io/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://dctmz.github.io/blog/tags/blog/"},{"name":"github","slug":"github","permalink":"https://dctmz.github.io/blog/tags/github/"},{"name":"pure","slug":"pure","permalink":"https://dctmz.github.io/blog/tags/pure/"}]}